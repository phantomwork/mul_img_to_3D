#!/usr/bin/env python

import os
import sys

import argparse
import matplotlib.pyplot as pl
import numpy as np
import cv2

from opensfm import dataset
from opensfm import features
from opensfm import matching
from opensfm import io
from opensfm import csfm
import opensfm.reconstruction as reconstruct


def redirect_print():
    reset = sys.stdout
    f = open(os.devnull, 'w')
    sys.stdout = f

    return reset


def reset_print(f):
    sys.stdout = f


def show_images(plot, im1, im2):
    h1, w1, c = im1.shape
    h2, w2, c = im2.shape
    image = np.zeros((max(h1, h2), w1+w2, 3), dtype=im1.dtype)
    image[0:h1, 0:w1, :] = im1
    image[0:h2, w1:(w1+w2), :] = im2
    plot.imshow(image)


def plot_points(plot, im1, p1, point_format1='ob', im2=None, p2=None, point_format2='ob'):
    h1, w1, c = im1.shape
    p1d = features.denormalized_image_coordinates(p1, w1, h1)
    plot.plot(p1d[:, 0], p1d[:, 1], point_format1)

    if im2 is None or p2 is None:
        return

    h2, w2, c = im2.shape
    p2d = features.denormalized_image_coordinates(p2, w2, h2)

    plot.plot(p2d[:, 0] + w1, p2d[:, 1], point_format2)


def plot_matches(plot, im1, im2, p1, p2, line_format='c', point_format='ob'):
    h1, w1, c = im1.shape
    h2, w2, c = im2.shape
    p1d = features.denormalized_image_coordinates(p1, w1, h1)
    p2d = features.denormalized_image_coordinates(p2, w2, h2)
    for a, b in zip(p1d, p2d):
        plot.plot([a[0], b[0] + w1], [a[1], b[1]], line_format)

    plot_points(plot, im1, p1, point_format, im2, p2, point_format)


def create_subplot(figure, rows, columns, index, title, width):
    subplot = figure.add_subplot(rows, columns, index)
    subplot.axis('off')
    pl.xlim(0, width)
    subplot.text(0.5, 0.9,
                 title,
                 horizontalalignment='center',
                 fontsize=12,
                 transform=subplot.transAxes)

    return subplot


def plot_points_sub(figure, rows, columns, index, title, im1, im2, p1, p2, point_format1, point_format2):
    subplot = create_subplot(figure, rows, columns, index, title, im1.shape[1] + im2.shape[1])

    show_images(subplot, im1, im2)
    plot_points(subplot, im1, p1, point_format1, im2, p2, point_format2)

    return subplot


def plot_matches_sub(figure, rows, columns, index, title, im1, im2, p1, p2, line_format, point_format):
    subplot = create_subplot(figure, rows, columns, index, title, im1.shape[1] + im2.shape[1])

    show_images(subplot, im1, im2)
    plot_matches(subplot, im1, im2, p1, p2, line_format, point_format)

    return subplot


def display_figure(figure, save_figs, data=None, file_name=''):
    figure.subplots_adjust(left=0.01, bottom=0, right=0.99, top=0.97, wspace=0.04, hspace=0)

    if save_figs:
        p = data.data_path + '/plot_inliers'
        io.mkdir_p(p)
        figure.savefig(p + '/' + file_name, dpi=100)
        pl.close()
    else:
        pl.show()


def reproject_tracks(im, tracks, reconstruction):
    p = []
    for track in tracks:
        shot = reconstruction['shots'][im]
        camera = reconstruction['cameras'][shot['camera']]
        point = reconstruction['points'][str(track)]

        p.append(reconstruct.reproject(camera, shot, point))

    return np.array(p) if len(p) else np.empty((0, 2), int)


def triangulate_tracks(tracks, reconstruction, graph, min_ray_angle):
    succeeded = []

    for track in tracks:
        # Triangulate with 1 as reprojection threshold to avoid excluding tracks because of error.
        reconstruct.triangulate_track(str(track), graph, reconstruction, {}, {}, {}, 1, min_ray_angle)
        succeeded.append(True) if str(track) in reconstruction['points'] else succeeded.append(False)

    return np.array(succeeded)


def find_reconstruction(images, data):
    reconstructions = data.load_reconstruction()
    reconstruction = None

    for r in reconstructions:
        found = True
        for im in images:
            if im not in r['shots']:
                found = False
                break

        if found:
            reconstruction = r
            break

    return reconstruction


def reconstruction_tracks(tracks, reconstruction):
    r_tracks = []
    n_tracks = []

    for track in tracks:
        if str(track[0]) in reconstruction['points']:
            r_tracks.append(track)
        else:
            n_tracks.append(track)

    r_tracks = np.array(r_tracks) if len(r_tracks) else np.empty((0, tracks.shape[1]), int)
    n_tracks = np.array(n_tracks) if len(n_tracks) else np.empty((0, tracks.shape[1]), int)

    return r_tracks, n_tracks


def load_points(im, data):
    p, f, c = data.load_features(im)
    return np.array(p[:, :2], np.float64)


def load_common_tracks(im1, im2, graph):
    t1, t2 = graph[im1], graph[im2]
    tc, p1, p2 = dataset.common_tracks(graph, im1, im2)

    common_tracks = []
    for t in tc:
        common_tracks.append(np.array([int(t), t1[t]['feature_id'], t2[t]['feature_id']]))

    return np.array(common_tracks) if len(common_tracks) else np.empty((0, 3), int)


def load_tracks(im, graph):
    tn = graph[im]

    tracks = []
    for t in tn:
        tracks.append(np.array([int(t), tn[t]['feature_id']]))

    return np.array(tracks) if len(tracks) else np.empty((0, 2), int)


def matches(a1, a2, map_function):
    """ Retrieves the row arrays in a1 that has an equal row array in a2 and the row arrays in a1 that
         does not have an equal row array in a2.
    :param a1: Numpy array of arrays.
    :param a2: Numpy array of arrays.
    :param map_function: Function mapping the array a1 to another array..
    :return: An array with the mapped rows in a1 that correspond to any row in a2 as well as an array with
             the mapped rows in a1 that do not correspond with an array in a2.
    """
    m = []
    nm = []

    for arr1 in a1:
        found = False
        for arr2 in a2:
            if np.array_equal(map_function(arr1), arr2):
                found = True
                break

        if not found:
            nm.append(arr1)
        else:
            m.append(arr1)

    m = np.array(m) if len(m) else np.empty((0, a1.shape[1]), int)
    nm = np.array(nm) if len(nm) else np.empty((0, a1.shape[1]), int)

    return m, nm


def create_matches_figure(im1, im2, data, save_figs=False):
    fig = pl.figure(figsize=(24, 12))
    fig.suptitle('Matches ({0}): {1} - {2}'.format(data.feature_type().upper(), im1, im2),
                 fontsize=14, fontweight='bold')

    im1_array = data.image_as_array(im1)
    im2_array = data.image_as_array(im2)

    # Calculate symmetric matches.
    p1, f1, c1 = data.load_features(im1)
    i1 = data.load_feature_index(im1, f1)

    p2, f2, c2 = data.load_features(im2)
    i2 = data.load_feature_index(im2, f2)

    symmetric_matches = matching.match_symmetric(f1, i1, f2, i2, data.config)

    if symmetric_matches.shape[0] < 8:
        print 'Not enough matches for eight point algorithm: ' + str(symmetric_matches.shape[0])
        return

    # Plot features
    features_title = 'Features (loaded): {0} - {1}, {2} - {3}'.format(im1, p1.shape[0], im2, p2.shape[0])
    plot_points_sub(fig, 2, 2, 1, features_title, im1_array, im2_array, p1, p2, 'ob', 'om')

     # Plot symmetric matches.
    s_matches1 = p1[symmetric_matches[:, 0]]
    s_matches2 = p2[symmetric_matches[:, 1]]

    plot_matches_sub(fig, 2, 2, 3,
                     'Symmetric matches (calculated): {0}'.format(symmetric_matches.shape[0]),
                     im1_array, im2_array,
                     s_matches1, s_matches2,
                     'c', 'ob')

    # Calculate robust matches and plot inliers.
    robust_matches = matching.robust_match(p1, p2, symmetric_matches, data.config)

    r_matches1 = p1[robust_matches[:, 0]]
    r_matches2 = p2[robust_matches[:, 1]]

    threshold = data.config.get('robust_matching_threshold', 0.006)
    plot_matches_sub(fig, 2, 2, 2,
                     'Robust matching inliers (calculated with RANSAC 8 point algorithm): {0}. Threshold: {1:.4f}'.format(
                         robust_matches.shape[0], threshold),
                     im1_array, im2_array,
                     r_matches1, r_matches2,
                     'g', 'oy')

    # Plot robust matching outliers.
    outliers = matches(symmetric_matches, robust_matches, lambda a: a)[1]
    outliers1 = p1[outliers[:, 0]]
    outliers2 = p2[outliers[:, 1]]

    plot_matches_sub(fig, 2, 2, 4,
                     'Robust matching outliers (calculated): {0}. Threshold: {1:.4f}'.format(outliers.shape[0], threshold),
                     im1_array, im2_array,
                     outliers1, outliers2,
                     'r', 'om')

    display_figure(fig, save_figs, data, '{0}_{1}_{2}_matches.jpg'.format(im1, im2, data.feature_type()))


def create_tracks_figure(im1, im2, data, save_figs=False):
    fig = pl.figure(figsize=(24, 12))
    fig.suptitle('Tracks ({0}): {1} - {2}'.format(data.feature_type().upper(), im1, im2),
                 fontsize=14, fontweight='bold')

    im1_array = data.image_as_array(im1)
    im2_array = data.image_as_array(im2)

    p1 = load_points(im1, data)
    p2 = load_points(im2, data)

    # Retrieve tracks and robust matches from file and plot tracks corresponding to
    # robust matches and tracks not corresponding to robust matches (linked tracks) in different colors.
    robust_matches = data.find_matches(im1, im2)
    robust_matches = np.array(robust_matches) if len(robust_matches) else np.empty((0, 2), int)

    graph = data.load_tracks_graph()
    tracks = load_common_tracks(im1, im2, graph)

    if tracks.shape[0] < 5:
        print 'Not enough tracks for five point algorithm: ' + str(tracks.shape[0])
        return

    robust_tracks, non_robust_tracks = matches(tracks, robust_matches, lambda a: a[1:])

    robust_points1 = p1[robust_tracks[:, 1]]
    robust_points2 = p2[robust_tracks[:, 2]]

    non_robust_points1 = p1[non_robust_tracks[:, 1]]
    non_robust_points2 = p2[non_robust_tracks[:, 2]]

    tracks_title = 'Common tracks (loaded): {0}. Robust match tracks: {1} / {2}. Linked tracks: {3}'.format(
        tracks.shape[0],
        robust_tracks.shape[0],
        robust_matches.shape[0],
        non_robust_tracks.shape[0])

    tracks_subplot = plot_matches_sub(
        fig, 2, 2, 1, tracks_title, im1_array, im2_array, robust_points1, robust_points2, 'c', 'ob')
    plot_matches(tracks_subplot, im1_array, im2_array, non_robust_points1, non_robust_points2, 'g', 'oy')

    # Plot inliers and outliers of the tracks from OpenCV find homography.
    track_points1 = p1[tracks[:, 1]]
    track_points2 = p2[tracks[:, 2]]

    threshold_h = data.config.get('homography_threshold', 0.004)
    H, inliers_h = cv2.findHomography(track_points1, track_points2, cv2.RANSAC, threshold_h)

    inliers_h = np.array(np.squeeze(inliers_h), np.bool)

    inliers_h1 = track_points1[inliers_h, :]
    inliers_h2 = track_points2[inliers_h, :]

    outliers_h1 = track_points1[~inliers_h, :]
    outliers_h2 = track_points2[~inliers_h, :]

    h_title = \
        'OpenCV find homography inliers (calculated): {0}. Outliers: {1}. Outlier ratio: {2:.3f}. Threshold: {3:.4f}'\
        .format(
            inliers_h.sum(), (~inliers_h).sum(), float((~inliers_h).sum()) / tracks.shape[0], threshold_h)

    h_subplot = plot_matches_sub(fig, 2, 2, 3, h_title, im1_array, im2_array, outliers_h1, outliers_h2, 'r', 'om')
    plot_matches(h_subplot, im1_array, im2_array, inliers_h1, inliers_h2, 'c', 'ob')

    # Plot inliers and outliers of the tracks from csfm two view reconstruction.
    f1 = data.load_exif(im1)['focal_prior']
    f2 = data.load_exif(im2)['focal_prior']

    threshold_t = data.config.get('five_point_algo_threshold', 0.006)
    R, t, cov, inliers_t = csfm.two_view_reconstruction(track_points1, track_points2, f1, f2, threshold_t)

    inliers_t1 = track_points1[inliers_t, :]
    inliers_t2 = track_points2[inliers_t, :]

    outliers_t = np.ones(track_points1.shape[0], dtype=bool)
    outliers_t[inliers_t] = False
    outliers_t1 = track_points1[outliers_t, :]
    outliers_t2 = track_points2[outliers_t, :]

    t_title = 'CSfM two view reconstruction inliers (calculated): {0}. Outliers: {1}. Threshold: {2:.4f}'.format(
        len(inliers_t), outliers_t.sum(), threshold_t)

    t_subplot = plot_matches_sub(fig, 2, 2, 2, t_title, im1_array, im2_array, inliers_t1, inliers_t2, 'c', 'ob')
    plot_matches(t_subplot, im1_array, im2_array, outliers_t1, outliers_t2, 'r', 'om')

    # Plot successfully reconstructed and failed 3D points by reconstruction bootstrap.
    stdout_reset = redirect_print()
    reconstruction = reconstruct.bootstrap_reconstruction(data, graph, im1, im2)
    reset_print(stdout_reset)

    if reconstruction:
        robust_rec_tracks, failed_robust = reconstruction_tracks(robust_tracks, reconstruction)
        non_robust_rec_tracks, failed_non_robust = reconstruction_tracks(non_robust_tracks, reconstruction)
        failed_rec_tracks = np.vstack((failed_robust, failed_non_robust))

        robust_rec_points1 = p1[robust_rec_tracks[:, 1]]
        robust_rec_points2 = p2[robust_rec_tracks[:, 2]]

        non_robust_rec_points1 = p1[non_robust_rec_tracks[:, 1]]
        non_robust_rec_points2 = p2[non_robust_rec_tracks[:, 2]]

        failed_rec_points1 = p1[failed_rec_tracks[:, 1]]
        failed_rec_points2 = p2[failed_rec_tracks[:, 2]]

        rec_title = \
            'Reconstructed 3D points (bootstrapped): {0}. Robust {1}. Linked: {2}. Failed: {3}. '.format(
                len(reconstruction['points']),
                robust_rec_tracks.shape[0],
                non_robust_rec_tracks.shape[0],
                failed_rec_tracks.shape[0]) + \
            'Triangulation threshold: {0:.4f}. Min ray angle: {1}.'.format(
                data.config.get('triangulation_threshold', 0.004),
                data.config.get('triangulation_min_ray_angle', 2.0))

        rec_plot = plot_matches_sub(
            fig, 2, 2, 4, rec_title, im1_array, im2_array, robust_rec_points1, robust_rec_points2, 'c', 'ob')
        plot_matches(rec_plot, im1_array, im2_array, non_robust_rec_points1, non_robust_rec_points2, 'g', 'oy')
        plot_matches(rec_plot, im1_array, im2_array, failed_rec_points1, failed_rec_points2, 'r', 'om')
    else:
        failed_title = \
            'Bootstrap failed. Less than {0} points. Triangulation threshold: {1:.4f}. Min ray angle: {2}.'\
            .format(
                data.config.get('five_point_algo_min_inliers', 50),
                data.config.get('triangulation_threshold', 0.004),
                data.config.get('triangulation_min_ray_angle', 2.0))
        create_subplot(fig, 2, 2, 4, failed_title, 100)

    display_figure(fig, save_figs, data, '{0}_{1}_{2}_tracks.jpg'.format(im1, im2, data.feature_type()))


def create_reconstruction_matches_figure(im1, im2, data, save_figs=False):
    fig = pl.figure(figsize=(15, 15))
    fig.suptitle('Reprojected reconstructed 3D points ({0}): {1} - {2}'.format(data.feature_type().upper(), im1, im2),
                 fontsize=18, fontweight='bold')

    im1_array = data.image_as_array(im1)
    im2_array = data.image_as_array(im2)

    p1 = load_points(im1, data)
    p2 = load_points(im2, data)

    graph = data.load_tracks_graph()
    tracks = load_common_tracks(im1, im2, graph)
    if tracks.shape[0] < 1:
        print 'No tracks to plot.'
        return

    reconstruction = find_reconstruction([im1, im2], data)
    if reconstruction is None:
        print '{0} and {1} does not exist in a common reconstruction.'.format(im1, im2)

    # Retrieve reconstructed tracks and plot as matches. Plot rejected tracks in other color.
    rec_tracks, non_rec_tracks = reconstruction_tracks(tracks, reconstruction)
    rec_track_points1 = p1[rec_tracks[:, 1]]
    rec_track_points2 = p2[rec_tracks[:, 2]]
    non_rec_track_points1 = p1[non_rec_tracks[:, 1]]
    non_rec_track_points2 = p2[non_rec_tracks[:, 2]]

    title = \
        'Common tracks: {0}. Reconstructed points: {1}. Triangulation and reprojection error removals: {2}. All loaded.'\
        .format(tracks.shape[0], rec_tracks.shape[0], tracks.shape[0] - rec_tracks.shape[0])

    t_subplot = \
        plot_matches_sub(fig, 2, 1, 1, title, im1_array, im2_array, rec_track_points1, rec_track_points2, 'c', 'ob')
    plot_matches(t_subplot, im1_array, im2_array, non_rec_track_points1, non_rec_track_points2, 'r', 'om')

    # Reproject reconstructed tracks. Triangulate rejected tracks and plot min ray angle removals and successfully
    # triangulated tracks in different colors.
    rp1 = reproject_tracks(im1, rec_tracks[:, 0], reconstruction)
    rp2 = reproject_tracks(im2, rec_tracks[:, 0], reconstruction)

    min_ray_angle = data.config.get('triangulation_min_ray_angle', 2.0)
    succeeded = triangulate_tracks(non_rec_tracks[:, 0], reconstruction, graph, min_ray_angle)
    reprojected1 = reproject_tracks(im1, non_rec_tracks[succeeded, 0], reconstruction)
    reprojected2 = reproject_tracks(im2, non_rec_tracks[succeeded, 0], reconstruction)

    triangulated_points1 = p1[non_rec_tracks[succeeded, 1]]
    triangulated_points2 = p2[non_rec_tracks[succeeded, 2]]
    excluded_points1 = p1[non_rec_tracks[~succeeded, 1]]
    excluded_points2 = p2[non_rec_tracks[~succeeded, 2]]

    title = 'Common tracks (loaded): {0}. Reprojected points (calculated): {1}.\n'\
        .format(tracks.shape[0], rec_tracks.shape[0]) + \
            'Rejected tracks: {0}. Re-triangulated: {1}. Min ray angle ({2} deg) removals: {3}.'\
        .format(non_rec_tracks.shape[0], succeeded.sum(), min_ray_angle, (~succeeded).sum())

    rec_plot = \
        plot_points_sub(fig, 2, 1, 2, title, im1_array, im2_array, rec_track_points1, rec_track_points2, 'ob', 'ob')
    plot_points(rec_plot, im1_array, rp1, '+w', im2_array, rp2, '+w')
    plot_points(rec_plot, im1_array, triangulated_points1, 'om', im2_array, triangulated_points2, 'om')
    plot_points(rec_plot, im1_array, reprojected1, '+w', im2_array, reprojected2, '+w')
    plot_points(rec_plot, im1_array, excluded_points1, 'or', im2_array, excluded_points2, 'or')

    display_figure(fig, save_figs, data, '{0}_{1}_{2}_reconstruction.jpg'.format(im1, im2, data.feature_type()))


def create_complete_reconstruction_figure(im, data, save_figs=False):
    fig = pl.figure(figsize=(18, 9))
    fig.suptitle('Reprojected reconstructed 3D points ({0}): {1}'.format(data.feature_type().upper(), im),
                 fontsize=14, fontweight='bold')

    reconstruction = find_reconstruction([im], data)
    if reconstruction is None:
        print '{0} does not exist in a reconstruction.'.format(im)

    im_array = data.image_as_array(im)
    p = load_points(im, data)

    graph = data.load_tracks_graph()
    tracks = load_tracks(im, graph)
    if tracks.shape[0] < 1:
        print 'No tracks for exist for {0}.'.format(im)
        return

    rec_tracks, non_rec_tracks = reconstruction_tracks(tracks, reconstruction)
    rec_track_points = p[rec_tracks[:, 1]]

    rp = reproject_tracks(im, rec_tracks[:, 0], reconstruction)

    title = 'Tracks: {0}. Included tracks (loaded): {1} with reprojected points (calculated).'\
        .format(tracks.shape[0], rec_tracks.shape[0])

    rec_plot = create_subplot(fig, 1, 2, 1, title, im_array.shape[1])
    rec_plot.imshow(im_array)
    plot_points(rec_plot, im_array, rec_track_points, 'ob')
    plot_points(rec_plot, im_array, rp, '+w')

    min_ray_angle = data.config.get('triangulation_min_ray_angle', 2.0)
    succeeded = triangulate_tracks(non_rec_tracks[:, 0], reconstruction, graph, min_ray_angle)
    reprojected = reproject_tracks(im, non_rec_tracks[succeeded, 0], reconstruction)

    triangulated_points = p[non_rec_tracks[succeeded, 1]]
    excluded_points = p[non_rec_tracks[~succeeded, 1]]

    title = 'Rejected tracks: {0}. Re-triangulated: {1}. Min ray angle ({2} deg) removals: {3}.'\
        .format(non_rec_tracks.shape[0], succeeded.sum(), min_ray_angle, (~succeeded).sum())

    non_rec_plot = create_subplot(fig, 1, 2, 2, title, im_array.shape[1])
    non_rec_plot.imshow(im_array)
    plot_points(non_rec_plot, im_array, triangulated_points, 'om')
    plot_points(non_rec_plot, im_array, excluded_points, 'or')
    plot_points(non_rec_plot, im_array, reprojected, '+w')

    display_figure(fig, save_figs, data, '{0}_{1}_complete_rec.jpg'.format(im, data.feature_type()))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Plot inlier and outlier matches between images')
    parser.add_argument('dataset',
                        help='path to the data set to be processed')
    parser.add_argument('image1',
                        help='name of the first image to show')
    parser.add_argument('image2',
                        help='name of the second image to show')
    parser.add_argument('--save_figs',
                        help='save figures instead of showing them',
                        action='store_true')
    parser.add_argument('--plot_all',
                        help='save figures instead of showing them',
                        action='store_true')

    args = parser.parse_args()
    ds = dataset.DataSet(args.dataset)
    image1 = args.image1
    image2 = args.image2
    save = args.save_figs

    create_matches_figure(image1, image2, ds, save)
    create_tracks_figure(image1, image2, ds, save)
    create_reconstruction_matches_figure(image1, image2, ds, save)

    if args.plot_all:
        create_complete_reconstruction_figure(image1, ds, save)
        create_complete_reconstruction_figure(image2, ds, save)