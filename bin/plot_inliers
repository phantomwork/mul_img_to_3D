#!/usr/bin/env python

import os
import sys

import argparse
import matplotlib.pyplot as pl
import numpy as np
import cv2

from opensfm import dataset
from opensfm import features
from opensfm import matching
from opensfm import io
from opensfm import csfm
import opensfm.reconstruction as reconstruct


def redirect_print():
    """ Redirects the sys.stdout to the null device.

    :return: The previous value of sys.stdout.
    """
    reset = sys.stdout
    f = open(os.devnull, 'w')
    sys.stdout = f

    return reset


def reset_print(f):
    """ Sets the sys.stdout device.

    :param f: The device.
    """
    sys.stdout = f


def show_images(plot, im1, im2):
    """ Shows the images in the supplied subplot. """
    h1, w1, c = im1.shape
    h2, w2, c = im2.shape
    image = np.zeros((max(h1, h2), w1+w2, 3), dtype=im1.dtype)
    image[0:h1, 0:w1, :] = im1
    image[0:h2, w1:(w1+w2), :] = im2
    plot.imshow(image)


def plot_points(plot, im1, p1, point_format1='ob', im2=None, p2=None, point_format2='ob'):
    """ Plots the points in the supplied subplot. """
    h1, w1, c = im1.shape
    p1d = features.denormalized_image_coordinates(p1, w1, h1)
    plot.plot(p1d[:, 0], p1d[:, 1], point_format1)

    if im2 is None or p2 is None:
        return

    h2, w2, c = im2.shape
    p2d = features.denormalized_image_coordinates(p2, w2, h2)

    plot.plot(p2d[:, 0] + w1, p2d[:, 1], point_format2)


def plot_matches(plot, im1, im2, p1, p2, line_format='c', point_format='ob'):
    """ Plots the matches in the supplied subplot. """
    h1, w1, c = im1.shape
    h2, w2, c = im2.shape
    p1d = features.denormalized_image_coordinates(p1, w1, h1)
    p2d = features.denormalized_image_coordinates(p2, w2, h2)
    for a, b in zip(p1d, p2d):
        plot.plot([a[0], b[0] + w1], [a[1], b[1]], line_format)

    plot_points(plot, im1, p1, point_format, im2, p2, point_format)


def create_subplot(figure, rows, columns, index, title, width, height, font_size=12):
    """ Creates a subplot with the supplied width. """
    subplot = figure.add_subplot(rows, columns, index)
    subplot.axis('off')
    pl.xlim(0, width)
    pl.ylim(height, 0)
    subplot.text(0.5, 1.04,
                 title,
                 horizontalalignment='center',
                 fontsize=font_size,
                 transform=subplot.transAxes)

    return subplot


def create_four_figure(title, single_column):
    """ Creates a figure for four subplots. """
    fig = pl.figure(figsize=(12, 21) if single_column else (24, 12))
    fig.suptitle(title, fontsize=14, fontweight='bold')
    rows = 4 if single_column else 2
    cols = 1 if single_column else 2

    return fig, rows, cols


def plot_points_sub(figure, rows, columns, index, title, im1, im2, p1, p2, point_format1, point_format2):
    """ Creates a subplot with the images and plots the points in each image. """
    subplot = create_subplot(figure, rows, columns, index, title,
                             im1.shape[1] + im2.shape[1], np.max([im1.shape[0], im2.shape[0]]))

    show_images(subplot, im1, im2)
    plot_points(subplot, im1, p1, point_format1, im2, p2, point_format2)

    return subplot


def plot_matches_sub(figure, rows, columns, index, title, im1, im2, p1, p2, line_format, point_format):
    """ Creates a subplot with the images and plots the points as matches. """
    subplot = create_subplot(figure, rows, columns, index, title,
                             im1.shape[1] + im2.shape[1], np.max([im1.shape[0], im2.shape[0]]))

    show_images(subplot, im1, im2)
    plot_matches(subplot, im1, im2, p1, p2, line_format, point_format)

    return subplot


def display_figure(figure, save_figs, data=None, file_name=''):
    """ Displays or saves a figure. """
    figure.subplots_adjust(left=0.01,
                           bottom=0,
                           right=0.99,
                           top=0.94 if save_figs else 0.91,
                           wspace=0.04,
                           hspace=0.14)

    if save_figs:
        p = data.data_path + '/plot_inliers'
        io.mkdir_p(p)
        figure.savefig(p + '/' + file_name, dpi=100)
        pl.close()
    else:
        pl.show()


def reproject_tracks(im, tracks, reconstruction):
    """ Reprojects the 3D points for a list of tracks for an image based on the reconstruction.

    :param im: The name of the image.
    :param tracks: Array of tracks that exist in the reconstruction.
    :param: reconstruction: A Reconstruction.
    :return: An array of reprojected track points where each row contains x and y values.
    """
    p = []
    for track in tracks:
        shot = reconstruction['shots'][im]
        camera = reconstruction['cameras'][shot['camera']]
        point = reconstruction['points'][str(track)]

        p.append(reconstruct.reproject(camera, shot, point))

    return np.array(p) if len(p) else np.empty((0, 2), int)


def triangulate_tracks(tracks, reconstruction, graph, min_ray_angle):
    """ Triangulates a list of tracks.

    :param tracks: The array of tracks.
    :param reconstruction: The reconstruction.
    :param: graph, The tracks graph.
    :param: min_ray_angle: The minimum ray angle difference for a triangulation to be considered valid.
    :return: An array of booleans determining if each track was successfully triangulated or not.
    """
    succeeded = []

    for track in tracks:
        # Triangulate with 1 as reprojection threshold to avoid excluding tracks because of error.
        reconstruct.triangulate_track(str(track), graph, reconstruction, {}, {}, {}, 1, min_ray_angle)
        succeeded.append(True) if str(track) in reconstruction['points'] else succeeded.append(False)

    return np.array(succeeded)


def find_reconstruction(images, data):
    """ Finds a reconstruction in which all images exist.

    :param images: List of image names.
    :param data: The data set.
    :return: The reconstruction that contains all images. None if no reconstruction was found.
    """
    reconstructions = data.load_reconstruction()
    reconstruction = None

    for r in reconstructions:
        found = True
        for im in images:
            if im not in r['shots']:
                found = False
                break

        if found:
            reconstruction = r
            break

    return reconstruction


def reconstruction_tracks(tracks, reconstruction):
    """ Gets the set of tracks in a list of tracks that exist in a reconstruction as well as the ones that does not
        belong to the reconstruction.

    :param tracks: The list of tracks.
    :param reconstruction: The reconstruction.
    :return: An array with the rows containing the track arrays that existed in the reconstruction. Another array
             with the rows containing the track arrays that did not belong to the reconstruction
    """
    r_tracks = []
    n_tracks = []

    for track in tracks:
        if str(track[0]) in reconstruction['points']:
            r_tracks.append(track)
        else:
            n_tracks.append(track)

    r_tracks = np.array(r_tracks) if len(r_tracks) else np.empty((0, tracks.shape[1]), int)
    n_tracks = np.array(n_tracks) if len(n_tracks) else np.empty((0, tracks.shape[1]), int)

    return r_tracks, n_tracks


def load_points(im, data):
    """ Loads the feature points for an image

    :param im: The name of the image.
    :param data: The data set.
    :return: An array with rows containing the x and y coordinates for the features in the image.
    """
    p, f, c = data.load_features(im)
    return np.array(p[:, :2], np.float64)


def load_common_tracks(im1, im2, graph):
    """ Loads the common track ids and corresponding feature ids for two images in a graph.

    :param im1: The name of the first image.
    :param im2: The name of the second image.
    :param graph: The track graph.
    :return: An array with rows containing a track id and the corresponding feature id for the first and second image.
    """
    t1, t2 = graph[im1], graph[im2]
    tc, p1, p2 = dataset.common_tracks(graph, im1, im2)

    common_tracks = []
    for t in tc:
        common_tracks.append(np.array([int(t), t1[t]['feature_id'], t2[t]['feature_id']]))

    return np.array(common_tracks) if len(common_tracks) else np.empty((0, 3), int)


def load_tracks(im, graph):
    """ Loads the track ids and corresponding feature ids for an image in a graph.

    :param im: The name of the image.
    :param graph: The track graph.
    :return: An array with rows containing a track id and the corresponding feature id.
    """
    tn = graph[im]

    tracks = []
    for t in tn:
        tracks.append(np.array([int(t), tn[t]['feature_id']]))

    return np.array(tracks) if len(tracks) else np.empty((0, 2), int)


def matches(a1, a2, map_function):
    """ Retrieves the row arrays in a1 that has an equal row array in a2 and the row arrays in a1 that
        does not have an equal row array in a2.

    :param a1: Numpy array of arrays.
    :param a2: Numpy array of arrays.
    :param map_function: Function mapping the array a1 to another array.
    :return: An array with the mapped rows in a1 that correspond to any row in a2 as well as an array with
             the mapped rows in a1 that do not correspond with an array in a2.
    """
    m = []
    nm = []

    for arr1 in a1:
        found = False
        for arr2 in a2:
            if np.array_equal(map_function(arr1), arr2):
                found = True
                break

        if not found:
            nm.append(arr1)
        else:
            m.append(arr1)

    m = np.array(m) if len(m) else np.empty((0, a1.shape[1]), int)
    nm = np.array(nm) if len(nm) else np.empty((0, a1.shape[1]), int)

    return m, nm


def create_matches_figure(im1, im2, data, save_figs=False, single_column=False):
    fig, rows, cols = \
        create_four_figure('Tracks ({0}): {1} - {2}'.format(data.feature_type().upper(), im1, im2), single_column)

    im1_array = data.image_as_array(im1)
    im2_array = data.image_as_array(im2)

    # Calculate symmetric matches.
    p1, f1, c1 = data.load_features(im1)
    i1 = data.load_feature_index(im1, f1)

    p2, f2, c2 = data.load_features(im2)
    i2 = data.load_feature_index(im2, f2)

    symmetric_matches = matching.match_symmetric(f1, i1, f2, i2, data.config)

    if symmetric_matches.shape[0] < 8:
        print 'Not enough matches for eight point algorithm: ' + str(symmetric_matches.shape[0])
        return

    # Plot features
    features_title = 'Features (loaded): {0} - {1}, {2} - {3}'.format(im1, p1.shape[0], im2, p2.shape[0])
    plot_points_sub(fig, rows, cols, 1, features_title, im1_array, im2_array, p1, p2, 'ob', 'om')

     # Plot symmetric matches.
    s_matches1 = p1[symmetric_matches[:, 0]]
    s_matches2 = p2[symmetric_matches[:, 1]]

    plot_matches_sub(fig, rows, cols, 3,
                     'Symmetric matches (calculated): {0}'.format(symmetric_matches.shape[0]),
                     im1_array, im2_array,
                     s_matches1, s_matches2,
                     'c', 'ob')

    # Calculate robust matches and plot inliers.
    robust_matches = matching.robust_match(p1, p2, symmetric_matches, data.config)

    r_matches1 = p1[robust_matches[:, 0]]
    r_matches2 = p2[robust_matches[:, 1]]

    threshold = data.config.get('robust_matching_threshold', 0.006)
    plot_matches_sub(fig, rows, cols, 2,
                     'Robust matching inliers (calculated with RANSAC eight point algorithm): {0}. Threshold: {1:.4f}'
                     .format(robust_matches.shape[0], threshold),
                     im1_array, im2_array,
                     r_matches1, r_matches2,
                     'g', 'oy')

    # Plot robust matching outliers.
    outliers = matches(symmetric_matches, robust_matches, lambda a: a)[1]
    outliers1 = p1[outliers[:, 0]]
    outliers2 = p2[outliers[:, 1]]

    plot_matches_sub(fig, rows, cols, 4,
                     'Robust matching outliers (calculated): {0}. Threshold: {1:.4f}'.format(outliers.shape[0], threshold),
                     im1_array, im2_array,
                     outliers1, outliers2,
                     'r', 'om')

    display_figure(fig, save_figs, data, '{0}_{1}_{2}_matches.jpg'.format(im1, im2, data.feature_type()))


def create_tracks_figure(im1, im2, data, save_figs=False, single_column=False):
    fig, rows, cols = \
        create_four_figure('Tracks ({0}): {1} - {2}'.format(data.feature_type().upper(), im1, im2), single_column)

    im1_array = data.image_as_array(im1)
    im2_array = data.image_as_array(im2)

    p1 = load_points(im1, data)
    p2 = load_points(im2, data)

    # Retrieve tracks and robust matches from file and plot tracks corresponding to
    # robust matches and tracks not corresponding to robust matches (linked tracks) in different colors.
    robust_matches = data.find_matches(im1, im2)
    robust_matches = np.array(robust_matches) if len(robust_matches) else np.empty((0, 2), int)

    graph = data.load_tracks_graph()
    tracks = load_common_tracks(im1, im2, graph)

    if tracks.shape[0] < 5:
        print 'Not enough tracks for five point algorithm: ' + str(tracks.shape[0])
        return

    robust_tracks, non_robust_tracks = matches(tracks, robust_matches, lambda a: a[1:])

    robust_points1 = p1[robust_tracks[:, 1]]
    robust_points2 = p2[robust_tracks[:, 2]]

    non_robust_points1 = p1[non_robust_tracks[:, 1]]
    non_robust_points2 = p2[non_robust_tracks[:, 2]]

    tracks_title = 'Common tracks (loaded): {0}. Robust match tracks: {1} / {2}. Linked tracks: {3}'.format(
        tracks.shape[0],
        robust_tracks.shape[0],
        robust_matches.shape[0],
        non_robust_tracks.shape[0])

    tracks_subplot = plot_matches_sub(
        fig, rows, cols, 1, tracks_title, im1_array, im2_array, robust_points1, robust_points2, 'c', 'ob')
    plot_matches(tracks_subplot, im1_array, im2_array, non_robust_points1, non_robust_points2, 'g', 'oy')

    # Plot inliers and outliers of the tracks from OpenCV find homography.
    track_points1 = p1[tracks[:, 1]]
    track_points2 = p2[tracks[:, 2]]

    threshold_h = data.config.get('homography_threshold', 0.004)
    H, inliers_h = cv2.findHomography(track_points1, track_points2, cv2.RANSAC, threshold_h)

    inliers_h = np.array(np.squeeze(inliers_h), np.bool)

    inliers_h1 = track_points1[inliers_h, :]
    inliers_h2 = track_points2[inliers_h, :]

    outliers_h1 = track_points1[~inliers_h, :]
    outliers_h2 = track_points2[~inliers_h, :]

    h_title = \
        'OpenCV find homography inliers (calculated): {0}. Outliers: {1}. Outlier ratio: {2:.3f}. Threshold: {3:.4f}'\
        .format(
            inliers_h.sum(), (~inliers_h).sum(), float((~inliers_h).sum()) / tracks.shape[0], threshold_h)

    h_subplot = plot_matches_sub(fig, rows, cols, 3, h_title, im1_array, im2_array, outliers_h1, outliers_h2, 'r', 'om')
    plot_matches(h_subplot, im1_array, im2_array, inliers_h1, inliers_h2, 'c', 'ob')

    # Plot inliers and outliers of the tracks from csfm two view reconstruction.
    f1 = data.load_exif(im1)['focal_prior']
    f2 = data.load_exif(im2)['focal_prior']

    threshold_t = data.config.get('five_point_algo_threshold', 0.006)
    R, t, cov, inliers_t = csfm.two_view_reconstruction(track_points1, track_points2, f1, f2, threshold_t)

    inliers_t1 = track_points1[inliers_t, :]
    inliers_t2 = track_points2[inliers_t, :]

    outliers_t = np.ones(track_points1.shape[0], dtype=bool)
    outliers_t[inliers_t] = False
    outliers_t1 = track_points1[outliers_t, :]
    outliers_t2 = track_points2[outliers_t, :]

    t_title = 'CSfM two view reconstruction inliers (calculated): {0}. Outliers: {1}. Threshold: {2:.4f}'.format(
        len(inliers_t), outliers_t.sum(), threshold_t)

    t_subplot = plot_matches_sub(fig, rows, cols, 2, t_title, im1_array, im2_array, inliers_t1, inliers_t2, 'c', 'ob')
    plot_matches(t_subplot, im1_array, im2_array, outliers_t1, outliers_t2, 'r', 'om')

    # Plot successfully reconstructed and failed 3D points by reconstruction bootstrap.
    stdout_reset = redirect_print()
    reconstruction = reconstruct.bootstrap_reconstruction(data, graph, im1, im2)
    reset_print(stdout_reset)

    if reconstruction:
        robust_rec_tracks, failed_robust = reconstruction_tracks(robust_tracks, reconstruction)
        non_robust_rec_tracks, failed_non_robust = reconstruction_tracks(non_robust_tracks, reconstruction)
        failed_rec_tracks = np.vstack((failed_robust, failed_non_robust))

        robust_rec_points1 = p1[robust_rec_tracks[:, 1]]
        robust_rec_points2 = p2[robust_rec_tracks[:, 2]]

        non_robust_rec_points1 = p1[non_robust_rec_tracks[:, 1]]
        non_robust_rec_points2 = p2[non_robust_rec_tracks[:, 2]]

        failed_rec_points1 = p1[failed_rec_tracks[:, 1]]
        failed_rec_points2 = p2[failed_rec_tracks[:, 2]]

        rec_title = \
            'Reconstructed 3D points (bootstrapped): {0}. Robust {1}. Linked: {2}. Failed: {3}. '.format(
                len(reconstruction['points']),
                robust_rec_tracks.shape[0],
                non_robust_rec_tracks.shape[0],
                failed_rec_tracks.shape[0]) + \
            'Triangulation threshold: {0:.4f}. Min ray angle: {1}.'.format(
                data.config.get('triangulation_threshold', 0.004),
                data.config.get('triangulation_min_ray_angle', 2.0))

        rec_plot = plot_matches_sub(
            fig, rows, cols, 4, rec_title, im1_array, im2_array, robust_rec_points1, robust_rec_points2, 'c', 'ob')
        plot_matches(rec_plot, im1_array, im2_array, non_robust_rec_points1, non_robust_rec_points2, 'g', 'oy')
        plot_matches(rec_plot, im1_array, im2_array, failed_rec_points1, failed_rec_points2, 'r', 'om')
    else:
        failed_title = \
            'Bootstrap failed. Less than {0} points. Triangulation threshold: {1:.4f}. Min ray angle: {2}.'\
            .format(
                data.config.get('five_point_algo_min_inliers', 50),
                data.config.get('triangulation_threshold', 0.004),
                data.config.get('triangulation_min_ray_angle', 2.0))
        create_subplot(fig, rows, cols, 4, failed_title, 100, 100)

    display_figure(fig, save_figs, data, '{0}_{1}_{2}_tracks.jpg'.format(im1, im2, data.feature_type()))


def create_reconstruction_matches_figure(im1, im2, data, save_figs=False):
    fig = pl.figure(figsize=(15, 15))
    fig.suptitle('Reprojected reconstructed 3D points ({0}): {1} - {2}'.format(data.feature_type().upper(), im1, im2),
                 fontsize=18, fontweight='bold')

    im1_array = data.image_as_array(im1)
    im2_array = data.image_as_array(im2)

    p1 = load_points(im1, data)
    p2 = load_points(im2, data)

    graph = data.load_tracks_graph()
    tracks = load_common_tracks(im1, im2, graph)
    if tracks.shape[0] < 1:
        print 'No tracks to plot.'
        return

    reconstruction = find_reconstruction([im1, im2], data)
    if reconstruction is None:
        print '{0} and {1} does not exist in a common reconstruction.'.format(im1, im2)

    # Retrieve reconstructed tracks and plot as matches. Plot rejected tracks in other color.
    rec_tracks, non_rec_tracks = reconstruction_tracks(tracks, reconstruction)
    rec_track_points1 = p1[rec_tracks[:, 1]]
    rec_track_points2 = p2[rec_tracks[:, 2]]
    non_rec_track_points1 = p1[non_rec_tracks[:, 1]]
    non_rec_track_points2 = p2[non_rec_tracks[:, 2]]

    title = \
        'Common tracks: {0}. Reconstructed points: {1}. Triangulation and reprojection error removals: {2}. All loaded.'\
        .format(tracks.shape[0], rec_tracks.shape[0], tracks.shape[0] - rec_tracks.shape[0])

    t_subplot = create_subplot(fig, 2, 1, 1, title,
                               im1_array.shape[1] + im2_array.shape[1],
                               np.max([im1_array.shape[0], im2_array.shape[0]]),
                               15)
    show_images(t_subplot, im1_array, im2_array)
    plot_matches(t_subplot, im1_array, im2_array, rec_track_points1, rec_track_points2, 'c', 'ob')
    plot_matches(t_subplot, im1_array, im2_array, non_rec_track_points1, non_rec_track_points2, 'r', 'om')

    # Reproject reconstructed tracks. Triangulate rejected tracks and plot min ray angle removals and successfully
    # triangulated tracks in different colors.
    rp1 = reproject_tracks(im1, rec_tracks[:, 0], reconstruction)
    rp2 = reproject_tracks(im2, rec_tracks[:, 0], reconstruction)

    min_ray_angle = data.config.get('triangulation_min_ray_angle', 2.0)
    succeeded = triangulate_tracks(non_rec_tracks[:, 0], reconstruction, graph, min_ray_angle)
    reprojected1 = reproject_tracks(im1, non_rec_tracks[succeeded, 0], reconstruction)
    reprojected2 = reproject_tracks(im2, non_rec_tracks[succeeded, 0], reconstruction)

    triangulated_points1 = p1[non_rec_tracks[succeeded, 1]]
    triangulated_points2 = p2[non_rec_tracks[succeeded, 2]]
    excluded_points1 = p1[non_rec_tracks[~succeeded, 1]]
    excluded_points2 = p2[non_rec_tracks[~succeeded, 2]]

    title = 'Common tracks (loaded): {0}. Reprojected points (calculated): {1}.\n'\
        .format(tracks.shape[0], rec_tracks.shape[0]) + \
            'Rejected tracks: {0}. Re-triangulated: {1}. Failed: {2} (behind a camera or min ray angle: {3} deg).'\
        .format(non_rec_tracks.shape[0], succeeded.sum(), (~succeeded).sum(), min_ray_angle)

    rec_plot = create_subplot(fig, 2, 1, 2, title,
                              im1_array.shape[1] + im2_array.shape[1],
                              np.max([im1_array.shape[0], im2_array.shape[0]]),
                              15)
    show_images(rec_plot, im1_array, im2_array)
    plot_points(rec_plot, im1_array, rec_track_points1, 'ob', im2_array, rec_track_points2, 'ob')
    plot_points(rec_plot, im1_array, rp1, '+w', im2_array, rp2, '+w')
    plot_points(rec_plot, im1_array, triangulated_points1, 'om', im2_array, triangulated_points2, 'om')
    plot_points(rec_plot, im1_array, reprojected1, '+w', im2_array, reprojected2, '+w')
    plot_points(rec_plot, im1_array, excluded_points1, 'or', im2_array, excluded_points2, 'or')

    display_figure(fig, save_figs, data, '{0}_{1}_{2}_reconstruction.jpg'.format(im1, im2, data.feature_type()))


def create_complete_reconstruction_figure(im, data, save_figs=False):
    fig = pl.figure(figsize=(18, 9))
    fig.suptitle('Reprojected reconstructed 3D points ({0}): {1}'.format(data.feature_type().upper(), im),
                 fontsize=14, fontweight='bold')

    reconstruction = find_reconstruction([im], data)
    if reconstruction is None:
        print '{0} does not exist in a reconstruction.'.format(im)

    im_array = data.image_as_array(im)
    p = load_points(im, data)

    graph = data.load_tracks_graph()
    tracks = load_tracks(im, graph)
    if tracks.shape[0] < 1:
        print 'No tracks for exist for {0}.'.format(im)
        return

    rec_tracks, non_rec_tracks = reconstruction_tracks(tracks, reconstruction)
    rec_track_points = p[rec_tracks[:, 1]]

    rp = reproject_tracks(im, rec_tracks[:, 0], reconstruction)

    title = 'Tracks: {0}. Included tracks (loaded): {1} with reprojected points (calculated).'\
        .format(tracks.shape[0], rec_tracks.shape[0])

    rec_plot = create_subplot(fig, 1, 2, 1, title, im_array.shape[1], im_array.shape[0])
    rec_plot.imshow(im_array)
    plot_points(rec_plot, im_array, rec_track_points, 'ob')
    plot_points(rec_plot, im_array, rp, '+w')

    min_ray_angle = data.config.get('triangulation_min_ray_angle', 2.0)
    succeeded = triangulate_tracks(non_rec_tracks[:, 0], reconstruction, graph, min_ray_angle)
    reprojected = reproject_tracks(im, non_rec_tracks[succeeded, 0], reconstruction)

    triangulated_points = p[non_rec_tracks[succeeded, 1]]
    excluded_points = p[non_rec_tracks[~succeeded, 1]]

    title = 'Rejected tracks: {0}. Re-triangulated: {1}. Failed: {2} (behind a camera or min ray angle: {3} deg).'\
        .format(non_rec_tracks.shape[0], succeeded.sum(), (~succeeded).sum(), min_ray_angle)

    non_rec_plot = create_subplot(fig, 1, 2, 2, title, im_array.shape[1], im_array.shape[0])
    non_rec_plot.imshow(im_array)
    plot_points(non_rec_plot, im_array, triangulated_points, 'om')
    plot_points(non_rec_plot, im_array, excluded_points, 'or')
    plot_points(non_rec_plot, im_array, reprojected, '+w')

    display_figure(fig, save_figs, data, '{0}_{1}_complete_rec.jpg'.format(im, data.feature_type()))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Plot inlier and outlier matches between images')
    parser.add_argument('dataset',
                        help='path to the data set to be processed')
    parser.add_argument('image1',
                        help='name of the first image to show')
    parser.add_argument('image2',
                        help='name of the second image to show')
    parser.add_argument('--save_figs',
                        help='save figures instead of showing them',
                        action='store_true')
    parser.add_argument('--single_col',
                        help='show figures in one column',
                        action='store_true')
    parser.add_argument('--plot_rec',
                        help='plots the reconstruction tracks for each image',
                        action='store_true')

    args = parser.parse_args()
    ds = dataset.DataSet(args.dataset)
    image1 = args.image1
    image2 = args.image2
    save = args.save_figs
    single = args.single_col

    print 'Plotting matches for {0} - {1}...'.format(image1, image2)
    create_matches_figure(image1, image2, ds, save, single)

    print 'Plotting tracks for {0} - {1}...'.format(image1, image2)
    create_tracks_figure(image1, image2, ds, save, single)

    print 'Plotting reconstruction matches for {0} - {1}...'.format(image1, image2)
    create_reconstruction_matches_figure(image1, image2, ds, save)

    if args.plot_rec:
        print 'Plotting complete reconstruction tracks for {0}...'.format(image1)
        create_complete_reconstruction_figure(image1, ds, save)

        print 'Plotting complete reconstruction tracks for {0}...'.format(image2)
        create_complete_reconstruction_figure(image2, ds, save)