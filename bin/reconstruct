#!/usr/bin/env python
import os.path, sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

import numpy as np
import argparse
import json
from labmv import transformations as tf
from labmv import dataset
from labmv import features
from labmv import multiview
import networkx as nx
from networkx.algorithms import bipartite


def best_initial_pair(graph):
    # Get the image connectivity graph.
    track_nodes, image_nodes = bipartite.sets(graph)
    image_graph = bipartite.weighted_projected_graph(graph, image_nodes)
    best_pair = None
    best_weight = 0
    for im1, im2, d in image_graph.edges(data=True):
        if d['weight'] > best_weight:
            best_weight = d['weight']
            best_pair = (im1, im2)
    return best_pair


def bootstrap_reconstruction(data, graph):
    im1, im2 = best_initial_pair(graph)
    print 'Matching image', im1, 'with image', im2
    d1 = data.exif_data(im1)
    d2 = data.exif_data(im2)
    tracks, p1, p2 = dataset.common_tracks(graph, im1, im2)

    print 'Number of common tracks', len(tracks)

    R, t, inliers, Xs = features.two_view_reconstruction(p1, p2, d1, d2)

    print 'Number of inliers', len(inliers)

    return {
        "cameras": {
            "main_camera": {
                "width": d1["width"],
                "height": d1["height"],
                "focal": d1["focal_ratio"] * d1["width"],
            },
        },

        "shots" : {
            im1: {
                "camera": "main_camera",
                "rotation": [0, 0, 0],
                "translation": [0, 0, 0],
            },
            im2: {
                "camera": "main_camera",
                "rotation": list(angleaxis(R)),
                "translation": list(t),
            },
        },

        "points" : {
            tracks[inlier]: {
                "coordinates": X,
            } for inlier, X in zip(inliers, Xs)
        },
    }

def next_image_to_add(graph, reconstruction, min_tracks=10):
    '''The non-reconstructed images that observes more reconstructed tracks.
    '''
    tracks, images = bipartite.sets(graph)
    max_tracks = 0
    best_image = None
    for image in images:
        if image not in reconstruction['shots']:
            common_tracks = 0
            for track in graph[image]:
                if track in reconstruction['points']:
                    common_tracks += 1
            if max_tracks < common_tracks:
                max_tracks = common_tracks
                best_image = image
    if max_tracks >= min_tracks:
        return best_image
    else:
        return None

def rotation_matrix(angleaxis):
    angle = np.linalg.norm(angleaxis)
    if angle < 1e-8:
        return np.eye(3)
    return tf.rotation_matrix(angle, angleaxis)[:-1, :-1]

def rotate(angleaxis, point):
    R = rotation_matrix(angleaxis)
    return R.dot(np.array(point))


def angleaxis(R):
    '''Compute angle-axis representation from a rotation matrix.
    '''
    T = np.identity(4)
    T[:3,:3] = R
    angle, direction, point = tf.rotation_from_matrix(T)
    return direction / np.linalg.norm(direction) * angle


def single_reprojection_error(camera, shot, point, observation):
    p = rotate(shot['rotation'], point['coordinates'])
    p += shot['translation']
    xp = p[0] / p[2]
    yp = p[1] / p[2]

    l1 = camera.get('k1', 0.0)
    l2 = camera.get('k2', 0.0)
    r2 = xp * xp + yp * yp;
    distortion = 1.0 + r2  * (l1 + l2  * r2)

    predicted_x = camera['focal'] * distortion * xp + camera['width'] / 2
    predicted_y = camera['focal'] * distortion * yp + camera['height'] / 2

    rx = predicted_x - observation[0]
    ry = predicted_y - observation[1]
    return np.sqrt(rx * rx + ry * ry)


def reprojection_error(graph, reconstruction):
    tracks, shots = bipartite.sets(graph)
    errors = []
    for shot_id in shots:
        if shot_id in reconstruction['shots']:
            for track_id in graph[shot_id]:
                if track_id in reconstruction['points']:
                    observation = graph[shot_id][track_id]['feature']
                    shot = reconstruction['shots'][shot_id]
                    camera = reconstruction['cameras'][shot['camera']]
                    point = reconstruction['points'][track_id]
                    errors.append(single_reprojection_error(camera, shot, point, observation))
    return np.mean(errors)


def resect(graph, reconstruction, shot_id):
    '''Add a shot to the reconstruction.
    '''
    xs = []
    Xs = []
    for track in graph[shot_id]:
        if track in reconstruction['points']:
            xs.append(graph[shot_id][track]['feature'])
            Xs.append(reconstruction['points'][track]['coordinates'])
    x = np.array(xs)
    X = np.array(Xs)
    kernel = multiview.ResectionLinearKernel(x, X)
    P, inliers, error = multiview.ransac(kernel, 3)
    K, R, t = multiview.KRt_from_P(P)
    print len(inliers), len(x)
    reconstruction['shots'][shot_id] = {
        "camera": "main_camera",
        "rotation": list(angleaxis(R)),
        "translation": list(t),
    }


def projection_matrix(camera, shot):
    f = camera['focal']
    w = camera['width']
    h = camera['height']
    K = np.array([[f, 0, w / 2],
                  [0, f, h / 2],
                  [0, 0, 1]])
    Rt = np.empty((3, 4))
    Rt[:,:3] = rotation_matrix(shot['rotation'])
    Rt[:, 3] = shot['translation']
    return K.dot(Rt)

def triangulate_shot_features(graph, reconstruction, shot_id):
    '''Reconstruct as many tracks seen in shot_id as possible.
    '''
    P_by_id = {}
    for track in graph[shot_id]:
        if track not in reconstruction['points']:
            Ps = []
            xs = []
            for shot in graph[track]:
                if shot in reconstruction['shots']:
                    if shot not in P_by_id:
                        s = reconstruction['shots'][shot]
                        c = reconstruction['cameras'][s['camera']]
                        P_by_id[shot] = projection_matrix(c, s)
                    Ps.append(P_by_id[shot])
                    xs.append(graph[track][shot]['feature'])
            if len(Ps) >= 2:
                X = multiview.triangulate(Ps, xs)
                # TODO(pau): reject points with high reprojection error.
                reconstruction[track] = {
                    "coordinates": list(X),
                }




# TODO(pau): implement a MLSE loss function for ceres.

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Compute reconstruction')
    parser.add_argument('dataset',
                        help='path to the dataset to be processed')
    args = parser.parse_args()

    data = dataset.DataSet(args.dataset)
    graph = data.tracks_graph()

    reconstruction = bootstrap_reconstruction(data, graph)
    reconstruction = features.bundle(data.tracks_file(), reconstruction)

    while True:
        next_image = next_image_to_add(graph, reconstruction)
        if not next_image:
            break
        print 'Adding {0} to the reconstruction'.format(next_image)
        resect(graph, reconstruction, next_image)
        reconstruction = features.bundle(data.tracks_file(), reconstruction)
        print 'BEFORE', reprojection_error(graph, reconstruction)
        triangulate_shot_features(graph, reconstruction, next_image)
        print 'AFTER', reprojection_error(graph, reconstruction)
        reconstruction = features.bundle(data.tracks_file(), reconstruction)

        if next_image == 'et005.jpg':
            break

    with open(data.reconstruction_file(), 'w') as fout:
        fout.write(json.dumps(reconstruction, indent=4))

