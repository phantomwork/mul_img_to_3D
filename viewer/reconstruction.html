<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Reconstruction Viewer</title>
        <meta charset="utf-8">
        <style>
            body {
                margin: 0px;
            }
        </style>
    </head>
    <body>
        <div id="ThreeJS" target="_blank"></div>

        <script src="js/jquery.js"></script>
        <script src="js/three.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="js/TrackballControls.js"></script>
        <script src="js/dat.gui.js"></script>

        <script>
            var container, camera, controls, scene, renderer;
            var particleSystem;
            var pMaterial;
            var reconstructions;
            var reconstruction_visibles = [];
            var reconstruction_groups = [];
            var camera_lines = {};
            var gps_lines = [];

            var options = {
              drawGPS: false,
              cameraSize: 1,
              pointSize: 0.4
            };

            getData();

            function addDatGui(){
                var gui = new dat.GUI();

                var f1 = gui.addFolder('Options');
                f1.add(options, 'pointSize', 0, 4)
                    .onChange(function(value) {
                        pMaterial.size = value;
                        render();
                    });
                f1.add(options, 'cameraSize', 0, 2)
                    .onChange(function(value) {
                        for (var r = 0; r < reconstructions.length; ++r)
                            updateCameraLines(reconstructions[r]);
                        render();
                    });
                f1.add(options, 'drawGPS')
                    .onChange(function(value) {
                        for (var i = 0; i < gps_lines.length; ++i) {
                            gps_lines[i].visible = value;
                        }
                        render();
                    });
                f1.open();

                var f3 = gui.addFolder('Reconstructions')
                reconstruction_visibles = [];
                for (var r = 0; r < reconstructions.length; ++r) {
                    reconstruction_visibles[r] = true;
                    f3.add(reconstruction_visibles, r, true)
                        .onChange(
                            (function(rr) {
                                return function (value) {
                                    reconstruction_groups[rr].traverse(
                                        function (object) { object.visible = value; } );
                                    render()
                                }
                            })(r)
                        );
                }
                f3.open();
            }

            function getData() {
                jQuery.getJSON("/data/" + window.location.hash.replace('#',''), function(data) {
                    if ('cameras' in data) {
                        reconstructions = [data];
                    } else {
                        reconstructions = data;
                    }
                    init();
                    animate();
                });
            }

            function rotate(vector, angleaxis) {
                var v = new THREE.Vector3(vector[0], vector[1], vector[2]);
                var axis = new THREE.Vector3(angleaxis[0],
                                             angleaxis[1],
                                             angleaxis[2]);
                var angle = axis.length();
                axis.normalize();
                var matrix = new THREE.Matrix4().makeRotationAxis(axis, angle);
                v.applyMatrix4(matrix);
                return v;
            }

            function opticalCenter(shot) {
                var angleaxis = [-shot.rotation[0],
                                 -shot.rotation[1],
                                 -shot.rotation[2]];
                var Rt = rotate(shot.translation, angleaxis);
                Rt.negate();
                return Rt;
            }

            function pixelToVertex(cam, shot, u, v, scale) {
                // Projection model:
                // xc = R * x + t
                // u = focal * xc / zc + width / 2
                // v = focal * yc / zc + height / 2

                var zc = scale;
                var xc = (u - cam.width / 2) / cam.focal * zc;
                var yc = (v - cam.height / 2) / cam.focal * zc;

                var xct = [xc - shot.translation[0],
                           yc - shot.translation[1],
                           zc - shot.translation[2]];


                var angleaxis = [-shot.rotation[0],
                                 -shot.rotation[1],
                                 -shot.rotation[2]];

                return rotate(xct, angleaxis);
            }

            function initCameraLines(reconstruction) {
                var lines = []
                for (var shot_id in reconstruction.shots) {
                    if (reconstruction.shots.hasOwnProperty(shot_id)) {
                        var lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, size: 0.1 })
                        var linegeo = cameraLineGeo(reconstruction, shot_id);
                        var line = new THREE.Line(linegeo, lineMaterial, THREE.LinePieces);
                        lines.push(line);
                        camera_lines[shot_id] = line;
                    }
                }
                return lines;
            }

            function cameraLineGeo(reconstruction, shot_id) {
                var shot = reconstruction.shots[shot_id];
                var cam = reconstruction.cameras[shot.camera];
                var ocenter = opticalCenter(shot);
                var top_left = pixelToVertex(cam, shot, 0, 0, options.cameraSize);
                var top_right = pixelToVertex(cam, shot, cam.width, 0, options.cameraSize);
                var bottom_right = pixelToVertex(cam, shot, cam.width, cam.height, options.cameraSize);
                var bottom_left = pixelToVertex(cam, shot, 0, cam.height, options.cameraSize);
                var linegeo = new THREE.Geometry();
                linegeo.vertices.push(ocenter);
                linegeo.vertices.push(top_left);
                linegeo.vertices.push(ocenter);
                linegeo.vertices.push(top_right);
                linegeo.vertices.push(ocenter);
                linegeo.vertices.push(bottom_right);
                linegeo.vertices.push(ocenter);
                linegeo.vertices.push(bottom_left);
                linegeo.vertices.push(top_left);
                linegeo.vertices.push(top_right);
                linegeo.vertices.push(top_right);
                linegeo.vertices.push(bottom_right);
                linegeo.vertices.push(bottom_right);
                linegeo.vertices.push(bottom_left);
                linegeo.vertices.push(bottom_left);
                linegeo.vertices.push(top_left);
                return linegeo;
            }

            function updateCameraLines(reconstruction) {
                for (var shot_id in reconstruction.shots) {
                    if (reconstruction.shots.hasOwnProperty(shot_id)) {
                        var linegeo = cameraLineGeo(reconstruction, shot_id);
                        camera_lines[shot_id].geometry.vertices = linegeo.vertices;
                        camera_lines[shot_id].geometry.verticesNeedUpdate = true;
                    }
                }
            }

            function init() {
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor( 0x202020, 1);

                container = document.getElementById( 'ThreeJS' );
                container.appendChild(renderer.domElement);
 
                camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
                camera.position.z = -50;

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.addEventListener('change', render);

                window.addEventListener('resize', onWindowResize, false);


                var scene_group = new THREE.Object3D();
                pMaterial = new THREE.PointCloudMaterial({
                      size: 0.3,
                      vertexColors: true,
                    });
                for (var r = 0; r < reconstructions.length; ++r) {
                    var reconstruction = reconstructions[r];
                    reconstruction_groups[r] = new THREE.Object3D();
                    var group = reconstruction_groups[r];

                    // Points.
                    var particles = new THREE.Geometry();
                    for (var point_id in reconstruction.points) {
                        if (reconstruction.points.hasOwnProperty(point_id)) {
                            var p = reconstruction.points[point_id].coordinates;
                            var c = reconstruction.points[point_id].color;
                            var color = new THREE.Color();
                            color.setRGB(c[0] / 255., c[1] / 255., c[2] / 255.)
                            particles.vertices.push(new THREE.Vector3(p[0], p[1], p[2]));
                            particles.colors.push(color);
                        }
                    }
                    particleSystem = new THREE.PointCloud(particles, pMaterial);
                    group.add(particleSystem)

                    // Cameras.
                    var lines = initCameraLines(reconstruction);
                    for (var i = 0; i < lines.length; ++i) {
                        group.add(lines[i]);
                    }

                    // GPS positions
                    for (var shot_id in reconstruction.shots) {
                        if (reconstruction.shots.hasOwnProperty(shot_id)) {
                            var shot = reconstruction.shots[shot_id];
                            var ocenter = opticalCenter(shot);
                            var gps = shot.gps_position;

                            var linegeo = new THREE.Geometry();
                            linegeo.vertices.push(
                                ocenter,
                                new THREE.Vector3(gps[0], gps[1], gps[2])
                            );
                            var lineMaterial = new THREE.LineBasicMaterial({ color: 0xff00ff });
                            var line = new THREE.Line(linegeo, lineMaterial, THREE.LinePieces);
                            line.visible = options.drawGPS;
                            group.add(line);
                            gps_lines.push(line);
                        }
                    }

                    scene_group.add(group);
                }

                // Axis
                var linegeo = new THREE.Geometry();
                linegeo.vertices = [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(1, 0, 0),
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 1, 0),
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 1)
                ];
                linegeo.colors = [
                    new THREE.Color( 0xff0000 ),
                    new THREE.Color( 0xff0000 ),
                    new THREE.Color( 0x00ff00 ),
                    new THREE.Color( 0x00ff00 ),
                    new THREE.Color( 0x0000ff ),
                    new THREE.Color( 0x0000ff )
                ];
                var lineMaterial = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    vertexColors: THREE.VertexColors
                });
                var line = new THREE.Line(linegeo, lineMaterial, THREE.LinePieces);
                scene_group.add(line);

                // Ground grid
                {
                    var linegeo = new THREE.Geometry();
                    var N = 20;
                    var scale = 2;
                    for (var i = 0; i <= 2 * N; ++i) {
                        linegeo.vertices.push(
                            new THREE.Vector3(scale * (i - N), scale * (-N), -2),
                            new THREE.Vector3(scale * (i - N), scale * ( N), -2),
                            new THREE.Vector3(scale * (-N), scale * (i - N), -2),
                            new THREE.Vector3(scale * ( N), scale * (i - N), -2)
                        );
                    }
                    var lineMaterial = new THREE.LineBasicMaterial({color: 0x555555});
                    var line = new THREE.Line(linegeo, lineMaterial, THREE.LinePieces);
                    scene_group.add(line);
                }

                scene_group.rotateX(-Math.PI / 2); // put scene right-side up

                scene = new THREE.Scene();
                scene.add(scene_group);

                addDatGui();
                render();
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                render();
            }

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
            }

            function render() {
                renderer.render( scene, camera );
            }

        </script>

    </body>
</html>
